"use strict";
var calendar_service_1 = require('./../../dp-calendar/config/calendar.service');
var core_1 = require('@angular/core');
var moment = require('moment');
var utils_service_1 = require('../../common/services/utils/utils.service');
var DayPickerService = (function () {
    function DayPickerService(calendarContainerService) {
        this.calendarContainerService = calendarContainerService;
        this.defaultConfig = {
            closeOnSelect: true,
            closeOnSelectDelay: 100,
            onOpenDelay: 0,
            disableKeypress: false,
            showNearMonthDays: true,
            drops: 'down',
            opens: 'right'
        };
    }
    DayPickerService.prototype.getConfig = function (config) {
        var _config = Object.assign({}, this.defaultConfig, config);
        if (config && config.allowMultiSelect && config.closeOnSelect === undefined) {
            _config.closeOnSelect = false;
        }
        return this.calendarContainerService.getConfig(_config);
    };
    DayPickerService.prototype.isDateValid = function (date, format) {
        if (date === '') {
            return true;
        }
        return moment(date, format, true).isValid();
    };
    DayPickerService.prototype.createValidator = function (_a, dateFormat) {
        var minDate = _a.minDate, maxDate = _a.maxDate;
        var isValid;
        var value;
        var validators = [];
        if (minDate) {
            validators.push({
                key: 'minDate',
                isValid: function () {
                    var _isValid = value.every(function (val) { return val.isSameOrAfter(minDate, 'day'); });
                    isValid = isValid ? _isValid : false;
                    return _isValid;
                }
            });
        }
        if (maxDate) {
            validators.push({
                key: 'maxDate',
                isValid: function () {
                    var _isValid = value.every(function (val) { return val.isSameOrBefore(maxDate, 'day'); });
                    isValid = isValid ? _isValid : false;
                    return _isValid;
                }
            });
        }
        return function validateInput(c) {
            var _this = this;
            isValid = true;
            if (c.value) {
                if (typeof c.value === 'string') {
                    var dateStrings = c.value.split(',').map(function (date) { return date.trim(); });
                    var validDateStrings = dateStrings.filter(function (date) { return _this.dayPickerService.isDateValid(date, _this.pickerConfig.format); });
                    value = validDateStrings.map(function (dateString) { return moment(dateString, dateFormat); });
                }
                else if (!Array.isArray(c.value)) {
                    value = [c.value];
                }
                else {
                    value = c.value.map(function (val) { return utils_service_1.UtilsService.convertToMoment(val, dateFormat); });
                }
            }
            else {
                return null;
            }
            if (!value.every(function (val) { return val.isValid(); })) {
                return {
                    format: {
                        given: c.value
                    }
                };
            }
            var errors = validators.reduce(function (map, err) {
                if (!err.isValid()) {
                    map[err.key] = {
                        given: value
                    };
                }
                return map;
            }, {});
            return !isValid ? errors : null;
        };
    };
    DayPickerService.decorators = [
        { type: core_1.Injectable },
    ];
    /** @nocollapse */
    DayPickerService.ctorParameters = function () { return [
        { type: calendar_service_1.CalendarService, },
    ]; };
    return DayPickerService;
}());
exports.DayPickerService = DayPickerService;
//# sourceMappingURL=day-picker.service.js.map