{"version":3,"file":"handleUndo.js","sourceRoot":"","sources":["../../src/handleUndo.ts"],"names":[],"mappings":"OACO,EAAC,WAAW,EAAC,MAAM,aAAa;AACvC,2BAA2B,WAA+B,EAC5B,UAAU;IACpC,IAAI,eAAe,GAAkB,EAAE,CAAC;IACxC,IAAI,YAAY,GAAG,SAAS,CAAC;IAC7B,MAAM,CAAC,UAAC,KAAU,EAAE,MAAc;QAC9B,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,KAAK,WAAW,CAAC,CAAC,CAAC;YAC9B,gCAAgC;YAChC,sDAAsD;YACtD,qCAAqC;YACrC,IAAI,UAAQ,GAAQ,YAAY,CAAC;YACjC,eAAe,GAAG,eAAe,CAAC,MAAM,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,KAAK,MAAM,CAAC,OAAO,EAAvB,CAAuB,CAAC,CAAC;YAC1E,sDAAsD;YACtD,yEAAyE;YACzE,eAAe,CAAC,OAAO,CAAC,UAAA,cAAc;gBAClC,OAAA,UAAQ,GAAG,WAAW,CAAC,UAAQ,EAAE,cAAc,CAAC;YAAhD,CAAgD,CAAC,CAAC;YACtD,MAAM,CAAC,UAAQ,CAAC;QACpB,CAAC;QACD,8EAA8E;QAC9E,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC7B,IAAI,YAAY,GAAG,WAAW,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;QAC9C,EAAE,CAAC,CAAC,eAAe,CAAC,MAAM,KAAK,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;YAC5C,IAAI,WAAW,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;YACrC,iDAAiD;YACjD,YAAY,GAAG,WAAW,CAAC,YAAY,EAAE,WAAW,CAAC,CAAC;YACtD,2BAA2B;YAC3B,eAAe,GAAG,eAAe,CAAC,KAAK,CAAC,CAAC,EAAE,UAAU,GAAG,CAAC,CAAC,CAAC;QAC/D,CAAC;QACD,MAAM,CAAC,YAAY,CAAC;IACxB,CAAC,CAAC;AACN,CAAC","sourcesContent":["import {ActionReducer, Action} from \"@ngrx/store\";\nimport {UNDO_ACTION} from \"./storeUndo\";\nexport function handleUndo(rootReducer: ActionReducer<any>,\n                              bufferSize): ActionReducer<any> {\n    let executedActions: Array<Action> = [];\n    let initialState = undefined;\n    return (state: any, action: Action) => {\n        if (action.type === UNDO_ACTION) {\n            // if the action is UNDO_ACTION,\n            // then call all the actions again on the rootReducer,\n            // except the one we want to rollback\n            let newState: any = initialState;\n            executedActions = executedActions.filter(eAct => eAct !== action.payload);\n            // update the state for every action untill we get the\n            // exact same state as before, but without the action we want to rollback\n            executedActions.forEach(executedAction =>\n                newState = rootReducer(newState, executedAction));\n            return newState;\n        }\n        // push every action that isn't an UNDO_ACTION to the executedActions property\n        executedActions.push(action);\n        let updatedState = rootReducer(state, action);\n        if (executedActions.length === bufferSize + 1) {\n            let firstAction = executedActions[0];\n            // calculate the state x (buffersize) actions ago\n            initialState = rootReducer(initialState, firstAction);\n            // keep the correct actions\n            executedActions = executedActions.slice(1, bufferSize + 1);\n        }\n        return updatedState;\n    };\n}\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}